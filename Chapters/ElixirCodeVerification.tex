\chapter{Elixir Code Verification}
\label{cap:elixirCodeVerification}

\chapterquote{Do not fear mistakes - there are none}{Miles Davis}

This chapter shows a system to verify code of the Elixir programming language.
First, we define a formal language to model a subset of sequential Elixir code
which also allows introducing ghost verification conditions. Then we show how to
verify it by means of the \gls{ir} defined in Chapter
\ref{cap:intermediateRepresentation}.

We also show an overview of our implementation, written in Elixir itself,
together with some of its implementation details.

\section{The L2 verification language}

In this section, we define the syntax of the L2 verification language, together
with some procedures and definitions with the aim to verify sequential Elixir
code.

\subsection{Syntax}

Let us define the set $\Exp{2}$ of sequential Elixir expressions given by the 
following grammar:

\[
\begin{array}{rcll}
\Exp{2} \ni E & ::= & e & \{ \textrm{L1 expression} \} \\
& | & P = E & \{ \textrm{pattern matching} \} \\
& | & E_1; E_2 & \{ \textrm{sequence} \} \\
& | & \caseE~E~\doW & \{ \textrm{case distinction} \} \\
& & \quad P_1~\whenE~f_1 \rightarrow E_1 \\
& & \quad \vdots\\
& & \quad P_n~\whenE~f_n \rightarrow E_n \\
& & \Wend \\
& | & \ghostE~\doW~S~\Wend & \{ \textrm{L1 ghost statement} \} \\
\end{array}
\]

Here $P$ denotes a pattern from a set $\Pat$ of patterns, defined by the 
following grammar:

\[
\Pat \ni P ::= c \mid x \mid [\:] \mid [P_1 \mid P_2] \mid \{ P_1, \ldots, P_n \}
\]

Note that the guard expressions $f_1, \ldots, f_n$ correspond to L1 expressions,
due to their restricted nature.

This language models a subset of the Elixir programming language with L1
expressions as their direct counterparts in Elixir, sequences as Elixir blocks,
$\caseE$ expressions, and a simplified version of its pattern matching
capabilities.  It also allows adding verification statements such as $\assertE$
and $\assumeE$ within $\ghostE$ blocks.

\subsection{Translation into L1}

In the following, given a set $A$, we use the notation $[A]$ to denote the set
of sequences of elements in $A$. If $x_1, \ldots, x_n$ we use the notation 
$[x_1, \ldots, x_n]$ to denote such a sequence. We also use a list comprehension
notation that is similar to the one in Haskell language. For example, $[(i, j)
\mid i \leftarrow [1, 2], j \leftarrow [3, 4, 5]]$.

Let us define a function: $\trEXP{\_} : \Exp{2} \rightarrow [\Stm \times
\Exp{1}]$ that, given an expression $E$ in the source language, generates a
sequence of pairs $(S, e)$ where $S$ is the L1 statement that models the
semantics of $E$, and $e$ is a L1 expression that represents the result to which
$E$ is evaluated. The reason behind translating an L2 expression into a sequence
is that control flow constructs such as $\caseE$ may yield to different possible
execution paths. 

We need an auxiliary function $\trMatch{\_}{\_} : \Exp{1} \times \Pat
\rightarrow \Exp{1}$ that, given an L1 expression $e$ and a pattern $P$, returns
another L1 expression that is a $\mathit{boolean}$ term and is evaluated to
$\true$ if and only if $e$ matches $P$. Its definition is as follows:

\[
\begin{array}{l}
\trMatch{e}{c} = e~\texttt{===}~{c}\\
\trMatch{e}{[\:]} = e~\texttt{===}~{[\:]} \\
\trMatch{e}{x} = \mathit{true}\\
\trMatch{e}{\{P_1,\ldots,P_n\}}\\
\qquad = \textit{is-tuple}(e)~\mathbf{and}~\textit{tuple-size}(e)~\texttt{===}~n~\mathbf{and}~(\mathbf{and}_{i=1}^n~\trMatch{\textit{elem}(e, i)}{P_i})\\
\trMatch{e}{[P_1\mid P_2]}\\
\qquad = \textit{is-nelist}(e)~\mathbf{and}~\trMatch{\textit{hd}(e)}{P_1}~\mathbf{and}~\trMatch{\textit{tl}(e)}{P_2}
\end{array}
\]

Also, $\mathit{vars}(P)$ is a function to denote the $L1$ variable expressions
that appear in a pattern $P$.

L2 expressions that are contained within the syntax of L1 are translated as they
are, but we generate an assertion to check if the singleton tuple which contains
that expression is a tuple. This will force to introduce the expression in the
generated L1 statements to be verified. Otherwise, bad formed expressions at the
top level whose translation yields to verification failures may be ignored
during the translation (e.g. \verb|true + 2|):

\[
\trEXP{e} = [(\assertE~\textit{is\mbox{-}tuple}(\{e\}), e)]
\]

Another approach would be to extend the L1 syntax with a new statement that just
checks an L1 expression.

A $\ghostE$ expression is translated into an arbitrary $L1$ expression, for
example the empty list, and the provided $L1$ statement as its semantics:

\[
\trEXP{\ghostE~\doW~S~\Wend} = [(S, [])]
\]

Expressions of the form $P = E$ are translated into assertions that check
whether the result of evaluating E matches the pattern $P$, and then assume the
equality between $P$ and $E$.

\[
\begin{array}{l}
\trEXP{P = E} = [(S_1;S_1',e_1), \dots, (S_n;S_n', e_n)] \\
\qquad 
\begin{array}{ll}
\textbf{where} & [(S_1,e_1),\dots,(S_n, e_n)] = \trEXP{E} \\
& \{y_1, \ldots, y_m\} = \mathit{vars}(P) \\
& \forall i \in \{1..n\}: S_i' = \left(
\begin{array}{l}
\assertE~\trMatch{e_i}{P};\\
\havocE~y_1;\\
\vdots\\
\havocE~y_m;\\
\assumeE~e_i ~\texttt{===}~ P\\
\end{array}
\right)
\end{array}
\end{array}
\]

In order to translate a sequence of expressions $E_1;E_2$ we have to append 
every statement generated from the translation of $E_2$ to every statement 
generated from the translation of $E_1$. We must deal carefully with $\ghostE$
expressions because, as its translation also returns an L1 expression, it must
be skipped in order to avoid altering the semantics of a block.

This will be its translation when the last expression is a $\ghostE$ one, taking
into account that \verb|;| is associative:

\[
\begin{array}{l}
\trEXP{E;\ghostE~\doW~S~\Wend} = [(S_i;S,e_i) \mid i \leftarrow [1..n]] \\
\qquad 
\begin{array}{ll}
\textbf{where} & [(S_1,e_1),\dots,(S_n, e_n)] = \trEXP{E} \\
\end{array}
\end{array}
\]

And this will be the general case when the previous one does not apply (i.e.
$E_2$ is not a sequence ending in a $\ghostE$):

\[
\begin{array}{l}
\trEXP{E_1;E_2} = [(S_i;S_j',e'_j) \mid i \leftarrow [1..n], j \leftarrow [1..m]] \\
\qquad 
\begin{array}{ll}
\textbf{where} & [(S_1,e_1),\dots,(S_n, e_n)] = \trEXP{E_1} \\
& [(S_1',e'_1),\dots,(S_m', e'_m)] = \trEXP{E_2} \\
\end{array}
\end{array}
\]

The translation of $\caseE$ expressions is more complex:

\[
\begin{array}{l}
\trEXP{\caseE~E~\doW~\overline{P_i~\whenE~f_i \rightarrow E_i}^n~\Wend}\\
\qquad = \left[ \begin{array}{l}
(S_j;\\
\havocE~y_{1};\\
\vdots\\
\havocE~y_{t};\\
\assertE~(\andE{e_{1,j}}{(\orE{(\textbf{not}~e_j~\texttt{===}~P_1)}{f_1})})\textbf{or}~\cdots\\
\quad\quad\textbf{or}~(\andE{e_{n,j}}{(\orE{(\textbf{not}~e_j~\texttt{===}~P_n)}{f_n})}); \\
\assumeE~(\textbf{not}~(e_{1,j}~\textbf{and}~(\orE{(\textbf{not}~e_j~\texttt{===}~P_1)}{f_1})))~\textbf{and}~\cdots\\
\quad\quad\textbf{and}~(\textbf{not}~(e_{i-1,j}~\textbf{and}~(\orE{(\textbf{not}~e_j~\texttt{===}~P_{i - 1})}{f_{i - 1}}))); \\
\assumeE~e_{i,j}~\textbf{and}~(\orE{(\textbf{not}~e_j~\texttt{===}~P_{i})}{f_{i}});\\
\assumeE~e_j~\texttt{===}~P_j; \\
S_{i,k}', e_{i,k}')
\end{array}  \middle\vert
\begin{array}{l}
j \leftarrow [1..m], \\
i \leftarrow [1..n], \\
k \leftarrow [1..s_i] \\
\end{array}
\right]\\
\begin{array}{ll}
\textbf{where} & [(S_1,e_1),\ldots,(S_m,e_m)] = \trEXP{E} \\
& \forall i \in \{1..n\}: [(S'_{i,1},e'_{i,1}),\ldots,(S'_{i,s_i},e'_{i,s_i})] = \trEXP{E_i} \\
& \forall i \in \{1..n\}, j \in \{1..m\}: e_{i,j} = \trMatch{e_j}{P_i} \\
& \{y_{1}, \ldots, y_{t}\} = \bigcup_{i = 1}^n\mathit{vars}(P_i) \\
\end{array}
\end{array}
\]

It can be described as, for each translation of $E$, for each branch and for 
each translation of the resulting expression of that branch:

\begin{enumerate}
  \item Declare the involved variables for every pattern matching. This is because guards $f_i$ may refer to variables bound in its pattern.
  \item Check that at least one pattern and guard holds. The guards $f_i$ are checked under the assumption that its pattern variables have been bound, which is a disjunction because there is no implication connective in L1 expressions.
  \item Assume that no previous pattern and guard holds, with the same considerations explained above, and that the current one does.
  \item Assume that the branch pattern does match.
  \item Include the generated L1 statements for the expression corresponding to that branch.
\end{enumerate}

This models appropriately the short-circuit semantics of the \verb|case|
construct because, if some branch will never be evaluated, assuming its pattern
and guard will make the hypothesis state inconsistent and everything would be
$\true$ after that, so it will not yield to validation failures.

\subsection{Verifying L2 expressions}
\label{sec:verificationprocess}

We will verify an L2 expression by verifying its corresponding translation into
or \gls{ir}.

First, for the verification of an L2 expression, as we want to allow reusing 
variable names, but this would be problematic in the generated L1 counterpart,
we consider a function $ssa$ to transform an L2 expression into \gls{ssa} form
as in the following example:

$$E =  (x = 2;x = 3 + x; y = x * x)$$
$$\mathit{ssa}(E) = (x_1 = 2;x_2 = 3 + x_1;y_1 = x_2 * x_2)$$

Then, we can obtain a single L1 statement that considers all the generated
statements by wrapping them inside $\blockE$ expressions to be verified 
independently one after the other:

\[
\begin{array}{l}
\mathit{verification}(E) = \blockE~S_i;\dots;\blockE~S_n\\
\qquad 
\begin{array}{ll}
\textbf{where} & [(S_1,e_1),\dots,(S_n, e_n)] = \trEXP{\mathit{ssa}(E)}
\end{array}
\end{array}
\]

Finally, the resulting expression from our \gls{ir} can be translated into our
low level verification language L0, as shown in Section \ref{sec:translationL0}
with the $\trStm{\_}$ function, which has its semantics defined in terms of the
$\gls{smt}$ problem.

\subsection{Verifying user-defined functions}

We will also define formally a representation for a set of user-defined
functions with its different overloads, which correspond to Elixir functions
that a user can define in an Elixir \verb|module|.

A single function definition of a function with arity $n$ is stated as

\[
\mathit{def} \equiv \left(\{ p \}  \quad (P_1, \dots, P_n)~B \quad \{ q \} \right)
\]

where the $p \in \Exp{1}$ and $q \in \Exp{1}$ denote a specified precondition
and a postcondition, $P_1, \dots, P_n$ are the parameter patterns and $B \in
\Exp{2}$ is its defined body.

Given a function named $f$ with arity $n$, we denote its overloaded definitions
as $\Defs{f/n}$ = $(\mathit{def}_1,\dots,\mathit{def}_k)$, where its definition
order matters. For each function, we are going to translate its definitions into
a $\caseE$ L2 expression that models them:

\[
\begin{array}{l}
\trDef{f/n} = \left[ \begin{array}{l}
\ghostE~\doW\\
\quad\havocE~\mathit{arg}_1;\\
\quad\vdots\\
\quad\havocE~\mathit{arg}_n\\
\Wend;\\
\caseE~\{\mathit{arg}_1,\dots,\mathit{arg}_n\}~\doW \\
\quad \{P_{1,1},\dots,P_{1,n}\}~\whenE~p_1 \rightarrow\\ 
\quad\quad \mathit{res} = B_1; \\
\quad\quad \ghostE~\doW\\ 
\quad\quad\quad\assumeE~res~\mathit{===}~f(\mathit{arg}_1,\dots,\mathit{arg}_n);\\
\quad\quad\quad\assertE~q_1\\
\quad\quad \Wend\\
\quad\vdots\\
\quad \{P_{k,1},\dots,P_{k,n}\}~\whenE~p_k \rightarrow\\ 
\quad\quad \mathit{res} = B_k; \\
\quad\quad \ghostE~\doW\\ 
\quad\quad\quad\assumeE~res~\mathit{===}~f(\mathit{arg}_1,\dots,\mathit{arg}_n);\\
\quad\quad\quad\assertE~q_k\\
\quad\quad \Wend\\
\quad \{\mathit{arg}_1,\dots,\mathit{arg}_n\} \rightarrow\\
\quad\quad\true\\ 
\Wend
\end{array}
\right]\\
\textbf{where } (\mathit{def}_1, \dots, \mathit{def}_k) = \Defs{f/n}\\
\phantom{\textbf{where }} \mathit{def}_i = \left(\{ p_i \}  \quad (P_{i,1}, \dots, P_{i,n})~B_i \quad \{ q_i \} \right) 
\end{array}
\]

We have used the fact that the rules in Elixir to select which function
definition takes effect are similar to those of the Elixir \verb|case|
expression, using the guards to assume the preconditions and its branch pattern
matching to allow using pattern matching also in the function parameters.

Also, a branch at the end that always succeeds is required because, as the 
function arguments are unknown at this point, it is not possible to know in 
advance if no branch will match. 

A set of function overloaded definitions can be verified by applying
$\trDef{\_}$ to each one of them and also applying the verification process
shown in Section \ref{sec:verificationprocess}.

\subsection{Unfolding user-defined functions}

\textcolor{red}{TODO}

Talk about generating ghost-free Elixir code.

Allowing L2 expressions in user-defined functions.

\subsection{Termination}

\textcolor{red}{TODO}

Show our current ideas about termination using term sizes.

\section{Implementation}

\textcolor{red}{TODO}: show examples in a separate section before this one if possible. Introduce this section.

For the translation process, we implement a function that given Elixir \gls{ast}
code that corresponds to an L2 program (i.e. its \gls{dsl}), yields a list of
pairs with the expression in L1 that represents its resulting value, and an L1
statement that models its meaning:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec translate_l2_exp(L2Exp.ast) 
  :: [{L1Exp.ast, L1Stm.ast}]
\end{lstlisting}

As in the previous \gls{dsl} translations, its definition syntax matches closely
the formal version, as in this example for assignment with pattern matching:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
def translate_l2_exp({:=, _, [p, e]}) do
  for {t, sem} <- translate(e) do
    {
      t,
      quote do
        unquote(sem)
        assert unquote(translate_match(p, e))

        unquote_splicing(
          for var <- vars(p) do
            quote do
              havoc unquote(var)
            end
          end
        )

        assume unquote(t) === unquote(p)
      end
    }
  end
end
\end{lstlisting}

where we also have implemented an auxiliary function to obtain the variables of
a pattern, as L1 variable expressions:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec vars(Pat.ast) :: MapSet.t(L1Exp.ast)
\end{lstlisting}

and a function to perform the pattern matching translation:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec translate_match(Pat.ast, L2Exp.ast) :: L1Exp.ast
\end{lstlisting}

For example, this is the case for lists:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
def translate_match({:|, _, [p1, p2]}, e) do
  tr_1 = translate_match(p1, quote(do: hd(unquote(e))))
  tr_2 = translate_match(p2, quote(do: tl(unquote(e))))

  quote(
    do:
      is_list(unquote(e)) and unquote(e) !== [] and
        unquote(tr_1) and unquote(tr_2)
  )
end
\end{lstlisting}

\textcolor{red}{TODO}: unfold if possible, and the verification process.

We have also implemented a function to transform an L2 program into 
\gls{ssa} form:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec l2_ssa(L2Exp.ast) :: L2Exp.ast
\end{lstlisting}

\textcolor{red}{TODO}: explain something about its implementation. We could
not use Macro.traverse for it.

By using first the function to transform L2 code into \gls{ssa} and then 
the L1 verification function from Section \ref{ir:details}, we can
define a verification function for L2 code as follows:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec verify_l2(Env.t(), L2Exp.ast()) :: [term()]
def verify_l2(env, e) do
  for {_, sem} <- translate_l2_exp(l2_ssa(e)) do
    L1Stm.eval(
      env,
      quote do
        block do
          unquote(sem)
        end
      end
    )
  end
  |> List.flatten()
end
\end{lstlisting}

Note that each possible path of the translation must be verified in an
independent proof context, so one option is to wrap each one into a \verb|block|
statement.
