\chapter{The L1 Intermediate Representation}
\label{cap:intermediateRepresentation}

\chapterquote{This process of using tools you built yesterday to help build bigger tools today is called abstraction, and it is the most powerful force I know of in the universe}{Sandy Maguire}

In this chapter, we develop an \gls{ir} for verification that is intended to be 
particularly suitable for languages like Elixir.

We start by providing its formal syntax, its translation into L0 expressions and
the built-in prelude that we have defined for modelling the Elixir semantics.
Then, we show some examples with our current implementation and give an overview
of its details.

\section{Syntax}

We denote by $\Sigma^{1} = \{ \texttt{===}, \texttt{<=}, \texttt{>=}, 
\texttt{+}, \texttt{-}, \dots \}$ the set of operators and functions allowed in
L1. We assume that for every element $f \in \Sigma^{1}$ there is an 
uninterpreted function symbol in $\Sigma^{0}$, which will be denoted by 
$\widehat{f}$. If $f$ has arity $n$, its corresponding function symbol 
$\widehat{f}$ will have sort $\Term \times \stackrel{n}{\dots} \times \Term
\rightarrow \Term$.

Let us define the syntax of L1 expressions and statements:

\[
\begin{array}{rcll}
\Exp{1} \ni e & ::= & c & \{ \textrm{literal} \}\\
& | & x & \{ \textrm{variable} \}\\
& | & \andE{e_1}{e_2} & \{ \textrm{conjunction} \}\\
& | & \orE{e_1}{e_2} & \{ \textrm{disjunction} \}\\
& | & [] & \{ \textrm{empty list} \}\\
& | & [e_1~|~e_2] & \{ \textrm{list cons cell} \}\\
& | & \{e_1, \ldots, e_n\} & \{ \textrm{tuple} \}\\
& | & f(e_1, \ldots, e_n) & \{ \textrm{function or operator application} \}\\

\\
\Stm \ni S & ::= & \skipE & \{ \textrm{do nothing} \} \\
 & | & \blockE~S & \{ \textrm{local scoped evaluation} \}\\
 & | & \havocE~x & \{ \textrm{variable declaration} \}\\
 & | & S_1;S_2 & \{ \textrm{sequential evaluation} \}\\
 & | & \assumeE~e & \{ \textrm{assume a formula} \}\\
 & | & \assertE~e & \{ \textrm{assert a formula} \}\\
\end{array}
\]

We also assume that for every function symbol $f \in \Sigma^{1}$ of arity $n$
there is an overloaded specification expressed in terms of L0 formulae. Here the
word \emph{overloaded} means that there could be many pre/post-condition pairs
for each function. For example, equality can be specified as follows:

\[
\begin{array}{l}
\{ \isinteger{x} \wedge \isinteger{y} \}\\
x~\texttt{===}~y\\
\{ \booleanvalue{\widehat{===}(x, y)} \Leftrightarrow \integervalue{x} = \integervalue{y} \}\\
\\
\{ \isboolean{x} \wedge \isboolean{y} \}\\
x~\texttt{===}~y\\
\{ \booleanvalue{\widehat{===}(x, y)} \Leftrightarrow \booleanvalue{x} = \booleanvalue{y} \}\\
\\
\vdots
\\
\\
\{\true\}\\
x~\texttt{===}~y\\
\{ \isboolean{\widehat{===}(x, y)} \wedge \booleanvalue{\widehat{===}(x, y)} \Leftrightarrow (x = y) \}\\
\\
\end{array}
\]

Here $\widehat{===}$ is the uninterpreted symbol in $\Sigma^{0}$ corresponding 
to Elixir's strict equality operator $\texttt{===} \in \Sigma^{1}$. We write the
former in prefix form in order to highlight the fact that it is an uninterpreted
function symbol in the logic. On the contrary, the $=$, $\Leftrightarrow$,
$\wedge$ in the specification above are actual connectives and operators of the
underlying logic.

We denote by $\sigma_1, \ldots, \sigma_m$ the specifications of a function $f
\in \Sigma^{1}$. Each one is a pair $(\varphi(x_1, \ldots, x_n), \psi(x_1,
\ldots, x_n))$, where the $x_i$ variables denote the parameters of the function.
We also denote by $\Spec{f}$ the set of specifications of $f$. They will be
built-in into the system in order to model the Elixir semantics.

\section{Semantics}

In this section, we show the translation process from L1 statements and
expressions into L0 expressions. Also, we show how the most relevant function
specifications to model the Elixir semantics are built-in into the system, but
we allow the user to introduce its own function definitions and specifications
in terms of L1 expressions.

\subsection{Built-in declarations}

During the translation of L1 statements and expressions into L0 expressions, we 
require some defined sorts, constants and functions in SMT-LIB. Every representation
of an L1 expression in the underlying logic has sort $\Term$:

\begin{verbatim}
; The sort Term
(declare-sort Term 0)
\end{verbatim}

Terms can be of a given type:

\begin{verbatim}
; The sort Type
(declare-sort Type 0)

; Modelled types
(declare-const int Type)
(declare-const bool Type)
(declare-const tuple Type)
(declare-const nonempty_list Type)

; All of them are different
(assert (distinct int bool))
(assert (distinct int tuple))
(assert (distinct int nonempty_list))
(assert (distinct bool tuple))
(assert (distinct bool nonempty_list))
(assert (distinct tuple nonempty_list))

; Type membership checking predicates
(declare-fun type (Term) Type)
(define-fun is_integer ((x Term)) Bool (= (type x) int))
(define-fun is_boolean ((x Term)) Bool (= (type x) bool))
(define-fun is_tuple ((x Term)) Bool (= (type x) tuple))

(define-fun is_nonempty_list ((x Term)) Bool 
  (= (type x) nonempty_list)
)

(define-fun is_list ((x Term)) Bool 
  (or (= x nil) (= (type x) nonempty_list))
)
\end{verbatim}

We also need a way to introduce and eliminate $\Term$s:

\begin{verbatim}
; Introduce literal values as corresponding Term
(declare-fun integer_lit (Int) Term)
(declare-fun boolean_lit (Bool) Term)

; In the case of boolean connectives, its value constructors
(declare-fun term_and (Term, Term) Term)
(declare-fun term_or (Term, Term) Term)

; In the case of lists, its value constructors
(declare-fun nil () Term)
(declare-fun cons (Term Term) Term)

; In the case of tuples, they are declared dynamically as
; (declare-fun tuple_n (Term, ..., Term) Term)

; The value of a Term of a given type in the underlying logic
(declare-fun integer_val (Term) Int)
(declare-fun boolean_val (Term) Bool)

; In the case of lists and tuples, its decomposition
(declare-fun hd (Term) Term)
(declare-fun tl (Term) Term)
(declare-fun tuple_size (Term) Int)
(declare-fun elem (Term Int) Term)
\end{verbatim}

These SMT-LIB commands will be executed at the beginning of our verification
process to initialize the solver.

\subsection{Translation into L0}

When it comes to assign a meaning to L1 statements and expressions, as this is
an \gls{ir}, we translate them into L0 expressions to verify them. For this, we
shall define two functions:

\[
\begin{array}{ll}
\trExp{\_}{\_} : & \Exp{0} \times \Exp{1} \rightarrow \Exp{0} \times \mathbb{T}\\
\trStm{\_} : & \Stm \rightarrow \Exp{0}
\end{array}
\]

Given an L1 expression $e$, the application $\trExp{\gamma}{e}$ returns a tuple 
$(\epsilon, t)$, in which $\epsilon$ is an L0 expression that models the
semantics of $e$, and $t$ is the term in the underlying logic that will be used
to refer to the result of $e$. The $\gamma$ models those facts that are known by
the time $e$ is evaluated and is needed to handle the short circuit-based 
semantics of $\mathbf{and}$ and $\mathbf{or}$. We are going to omit this
$\gamma$ parameter when it models no knowledge:

\[
\trExps{e} \equiv \trExp{\skipE}{e}
\]

Let us define $\trExp{\_}{\_}$ case by case. In the case of literals, we get:

\[
\trExp{\_}{c} \equiv (\addE~\istau{\taulit{\hat{c}}};\addE~\tauvalue{\taulit{\hat{c}}} = \hat{c}, \taulit{\hat{c}})
\]

where $\tau$ is the type of the literal, which can be determined at compile time
since it is a literal, and $\hat{c}$ is the constant in the underlying logic
represented by that literal. For example, the Elixir term $\mathbf{2}$
corresponds to the actual number $2 \in \mathbb{Z}$, so $\hat{\mathbf{2}} = 2$.

In the case of variables, we get:

\[
\trExp{\_}{x} \equiv (\skipE, \hat{x})
\]

It returns the logic variable $\hat{x}$ corresponding to the L1 variable $x$. 
No L0 expression is generated.

The L0 expressions generated by a tuple correspond to the ones generated by each
component, the projection function for each one and its tuple size function. Its
translated term is a specific tuple constructor for its size $n$ applied to its 
translated term components:

\[
\begin{array}{l}
\trExp{\gamma}{\{e_1, \ldots, e_n\}} \equiv (\epsilon_1; \dots; \epsilon_n;\epsilon;\epsilon'_1; \dots; \epsilon'_n, t)\\
\qquad \textbf{where } \forall i \in \{1..n\}. (\epsilon_i, t_i) = \trExp{\gamma}{e_i}\\
\qquad \phantom{\textbf{where }} t = \mathit{n\mbox{-}tuple}(t_1, \ldots, t_n)\\
\qquad \phantom{\textbf{where }} \epsilon = \addE~\istuple{t};\addE~\mathit{tuple\mbox{-}size}(t) = n\\
\qquad \phantom{\textbf{where }} \forall i \in \{1..n\}. \epsilon'_i = \addE~\mathit{elem}(t, i) = t_i\\
\end{array}
\]

The translation for lists is defined recursively, with the empty list as the
base case. The generated L0 expressions set the corresponding heads and tails 
for the generated list terms, and it does not require the second argument for
the list constructor to be a list:

\[
\begin{array}{l}
\trExp{\_}{[]} \equiv (
  \skipE, \mathit{nil}
)\\
\trExp{\gamma}{[e_1~|~e_2]} \equiv (\epsilon_1;\epsilon_2;\epsilon, t)\\
  \qquad \textbf{where } (\epsilon_1, t_1) = \trExp{\gamma}{e_1}\\ 
  \qquad \phantom{\textbf{where }} (\epsilon_2, t_2) = \trExp{\gamma}{e_2}\\ 
  \qquad \phantom{\textbf{where }} t = \mathit{cons}(t_1, t_2)\\ 
  \qquad \phantom{\textbf{where }} \epsilon = \left[
    \begin{array}{l}
      \addE~\isnelist{t};\\
      \addE~\mathit{hd}(t) = t_1;\\
      \addE~\mathit{tl}(t) = t_2\\
    \end{array}
  \right]
\end{array}
\]

A more complex case is that of function application:

\[
\begin{array}{l}
\trExp{\gamma}{f(e_1, \ldots, e_n)} \equiv (\epsilon_1; \dots; \epsilon_n; \epsilon; \overline{\epsilon_\sigma}^{\sigma \in \Spec{f}}, \widehat{f}(t_1, \ldots, t_n))\\
\qquad \textbf{where } \forall i \in \{1..n\}. (\epsilon_i, t_i) = \trExp{\gamma}{e_i}\\
\qquad \phantom{\textbf{where }} \epsilon = \left[ 
  \begin{array}{l}
  \whenUnsatW~\gamma;\addE~\neg \bigvee_{\sigma \in \Spec{f}}\Pre{\sigma}(t_1\ldots,t_n)\\
  \quad\doW~\skipE\\
  \quad\elseW~\failE\\
  \end{array}
  \right]\\
\qquad \phantom{\textbf{where }} \forall \sigma \in \Spec{f} \textrm{ such that } \sigma = (\varphi_\sigma(x_1\ldots,x_n), \psi_\sigma(x_1, \ldots, x_n)).\\
\qquad\qquad\qquad\qquad \epsilon_\sigma = \left[ 
\begin{array}{l}
\whenUnsatW~\gamma;\addE~\neg \varphi_\sigma(t_1\ldots,t_n)~\doW\\
\quad\addE~\varphi_\sigma(t_1\ldots,t_n);\\
\quad\addE~\psi_\sigma(t_1,\ldots,t_n)\\
\elseW~\skipE\\
\end{array}
\right] \\
\end{array}
\]

Firstly, we generate the L0 expression $\epsilon_i$ corresponding to each 
argument $e_i$, and its corresponding uninterpreted term $t_i$. Then, for 
each pre/post-condition pair of the specification of the function being
applied, we generate code that checks whether the precondition holds and, 
in case it does, we assert both the precondition and postcondition. Finally,
we also check that at least one preconditions holds.

We distinguish the cases of logical connectives from function application
because of their specific short-circuit semantics in Elixir:

\[
\begin{array}{l}
\trExp{\gamma}{\andE{e_1}{e_2}} \equiv (\epsilon, t)\\
\qquad \textbf{where }(\epsilon_1, t_1) = \trExp{\gamma}{e_1}\\
\qquad \phantom{\textbf{where }}(\epsilon_2, t_2) = \trExp{\gamma'}{e_2}\\
\qquad\qquad\qquad\qquad \gamma' = \gamma;\addE~\booleanvalue{t_1}\\
\qquad\qquad\qquad\qquad t = \widehat{\mathbf{and}}(t_1, t_2)\\
\qquad\qquad\qquad\qquad \epsilon = \left[ 
\begin{array}{l}
\epsilon_1;\\
\whenUnsatW~\gamma;\addE~\neg\isboolean{t_1}~\doW\\
\quad\whenUnsatW~\gamma;\addE~\booleanvalue{t_1}~\doW\\
\quad\quad\addE~\isboolean{t};\\
\quad\quad\addE~\neg\booleanvalue{t};\\
\quad\quad\addE~\neg\booleanvalue{t_1}\\
\quad\elseW\\
\quad\quad\epsilon_2;\\
\quad\quad\whenUnsatW~\gamma;\addE~\neg\booleanvalue{t_1}~\doW\\
\quad\quad\quad\addE~\booleanvalue{t_1}\\
\quad\quad\quad\addE~t = t_2\\
\quad\quad\elseW~\whenUnsatW~\gamma';\addE~\neg\isboolean{t_2}~\doW\\
\quad\quad\quad\addE~\isboolean{t};\\
\quad\quad\quad\addE~\booleanvalue{t} = \\
\quad\quad\quad\quad(\booleanvalue{t_1} \land \booleanvalue{t_2})\\
\quad\quad\elseW~\failE\\
\elseW~\failE
\end{array}
\right] \\
\end{array}
\]

In the translation for an $\mathbf{and}$ expression, we firstly check if 
the term to the left is boolean. Then, on the one hand, if it is known to be always 
$\false$, the resulting term is $\false$. On the other hand, if it 
is known to be always $\true$, the resulting term is the right one 
regardless of its type. Note that this right term has been translated with the 
knowledge that the left one is $\true$. If the value of the 
left term is not exactly known at this point, we check if the right term 
is a boolean, again with the knowledge that the left one is $\true$,
and translate the whole expression into the underlying logical conjunction.

The translation corresponding to $\mathbf{or}$ is analogous:

\[
\begin{array}{l}
\trExp{\gamma}{\orE{e_1}{e_2}} \equiv (\epsilon, t)\\
\qquad \textbf{where }(\epsilon_1, t_1) = \trExp{\gamma}{e_1}\\
\qquad \phantom{\textbf{where }}(\epsilon_2, t_2) = \trExp{\gamma'}{e_2}\\
\qquad\qquad\qquad\qquad \gamma' = \gamma;\addE~\neg\booleanvalue{t_1}\\
\qquad\qquad\qquad\qquad t = \widehat{\mathbf{or}}(t_1, t_2)\\
\qquad\qquad\qquad\qquad \epsilon = \left[ 
\begin{array}{l}
\epsilon_1;\\
\whenUnsatW~\gamma;\addE~\neg\isboolean{t_1}~\doW\\
\quad\whenUnsatW~\gamma;\addE~\neg\booleanvalue{t_1}~\doW\\
\quad\quad\addE~\isboolean{t};\\
\quad\quad\addE~\booleanvalue{t};\\
\quad\quad\addE~\booleanvalue{t_1}\\
\quad\elseW\\
\quad\quad\epsilon_2;\\
\quad\quad\whenUnsatW~\gamma;\addE~\booleanvalue{t_1}~\doW\\
\quad\quad\quad\addE~\neg\booleanvalue{t_1}\\
\quad\quad\quad\addE~t = t_2\\
\quad\quad\elseW~\whenUnsatW~\gamma';\addE~\neg\isboolean{t_2}~\doW\\
\quad\quad\quad\addE~\isboolean{t};\\
\quad\quad\quad\addE~\booleanvalue{t} = \\
\quad\quad\quad\quad(\booleanvalue{t_1} \lor \booleanvalue{t_2})\\
\quad\quad\elseW~\failE\\
\elseW~\failE
\end{array}
\right] \\
\end{array}
\]

Now we move on to L1 statements. The following ones are translated in a 
quite straightforward way:

\[
\begin{array}{l}
\trStm{\skipE} \equiv \skipE\\[1em]
\trStm{\blockE~S} \equiv \localE~\trStm{S}\\[1em]
\trStm{\havocE~x} \equiv \declareE{\widehat{x}}\\[1em]
\trStm{S_1;S_2} \equiv \trStm{S_1};\trStm{S_2}\\
\qquad \textbf{where }(\epsilon_1, t_1) = \trExps{e_1}\\
\qquad \phantom{\textbf{where }}(\epsilon_2, t_2) = \trExps{e_2}
\end{array}
\]

In the case of $\assumeE$, we generate the expression $\epsilon$ that 
corresponds to the expression being assumed and its uninterpreted term $t$. 
We ensure that the term $t$ actually denotes a boolean value and, in this 
case, we assert that this boolean value is $\true$:

\[
\trStm{\assumeE~e} \equiv 
\left[\begin{array}{l}
\epsilon;\\
\whenUnsatW~\addE~\neg\isboolean{t}\\
\quad\doW~\addE~\booleanvalue{t}\\
\quad\elseW~\failE\\
\end{array}\right]
\qquad \textbf{where}~(\epsilon, t) = \trExps{e}
\]

In the case of $\assertE$, we also generate the expression $\epsilon$ that 
corresponds to the expression being assumed and its uninterpreted term $t$. 
We ensure that the term $t$ actually denotes a boolean value and also that 
its boolean value is $\true$:

\[
\trStm{\assertE~e} \equiv
\left[\begin{array}{l}
\epsilon;\\
\whenUnsatW~\addE~\neg\isboolean{t}\\
\quad\doW~\skipE\\
\quad\elseW~\failE;\\
\whenUnsatW~\addE~\neg\booleanvalue{t}\\
\quad\doW~\addE~\booleanvalue{t}\\
\quad\elseW~\failE\\
\end{array}\right]
\qquad \textbf{where}~(\epsilon, t) = \trExps{e}
\]

\subsection{Built-in specifications}

In order to allow L1 expressions to model the semantics of built-in Elixir
functions and operators, the corresponding uninterpreted functions must be
declared in SMT-LIB with sort $\Term \times \stackrel{n}{\dots} \times \Term
\rightarrow \Term$, and our system must provide its corresponding built-in
specifications. We have explored some of them that are explained in this
section.

For integer arithmetic, the specification of $\texttt{+}$ can be defined as

\[
\begin{array}{l}
\{ \isinteger{x} \wedge \isinteger{y} \}\\
x~\texttt{+}~y\\
\{ \isinteger{\widehat{+}(x, y)} \wedge 
  \integervalue{\widehat{+}(x, y)} = \integervalue{x} + \integervalue{y} \}
\end{array}
\]

and it will be extended if we model other numeric types such as \verb|float|.
It is similar for $\texttt{-}$ and $\texttt{*}$. The unary version of
$\texttt{-}$ can be specified as follows:

\[
\begin{array}{l}
\{ \isinteger{x} \}\\
\texttt{-}~x\\
\{ \isinteger{\widehat{-}(x)} \wedge 
  \integervalue{\widehat{-}(x)} = -\integervalue{x} \}
\end{array}
\]

Similarly, the Elixir boolean negation can be specified as:

\[
\begin{array}{l}
\{ \isboolean{x} \}\\
\mathit{not}(x)\\
\{ \isboolean{\widehat{\mathit{not}}(x)} \wedge 
  \booleanvalue{\widehat{\mathit{not}}(x)} \Leftrightarrow \neg\booleanvalue{x} \}
\end{array}
\]

We have only provided the comparison for integer terms as

\[
\begin{array}{l}
\{ \isinteger{x} \wedge \isinteger{y} \}\\
x~\texttt{<}~y\\
\{ \isboolean{\widehat{<}(x, y)} \wedge 
  \booleanvalue{\widehat{<}(x, y)} \Leftrightarrow \integervalue{x} < \integervalue{y} \}
\end{array}
\]

and it is in the same way for $\texttt{>}$, $\texttt{<=}$ and $\texttt{>=}$. An
improvement would be to extend this for any term, including lists and tuples.

Term equality can be specified as

\[
\begin{array}{l}
\{ \isinteger{x} \wedge \isinteger{y} \}\\
x~\texttt{===}~y\\
\{ \booleanvalue{\widehat{===}(x, y)} \Leftrightarrow \integervalue{x} = \integervalue{y} \}\\
\\
\{ \isboolean{x} \wedge \isboolean{y} \}\\
x~\texttt{===}~y\\
\{ \booleanvalue{\widehat{===}(x, y)} \Leftrightarrow \booleanvalue{x} = \booleanvalue{y} \}\\
\\
\{ \islist{x} \wedge \islist{y} \}\\
x~\texttt{===}~y\\
\{ \booleanvalue{\widehat{===}(x, y)} \Leftrightarrow 
  (x = \mathit{nil} \wedge y = \mathit{nil})
  \vee (\mathit{hd}(x) = \mathit{hd}(y) \land \mathit{tl}(x) = \mathit{tl}(y)) \}\\
\\
\{ \istuple{x} \wedge \istuple{y} \wedge \mathit{tuple\mbox{-}size}(x) = \mathit{tuple\mbox{-}size}(y) \}\\
x~\texttt{===}~y\\
\{ \booleanvalue{\widehat{===}(x, y)} \Leftrightarrow 
  (\forall i. i >= 0 \wedge i < \mathit{tuple\mbox{-}size}(x) \Rightarrow \mathit{elem}(x, i) = \mathit{elem}(y, i)) \}\\
\\
\{ \istuple{x} \wedge \istuple{y} \wedge \mathit{tuple\mbox{-}size}(x) \neq \mathit{tuple\mbox{-}size}(y) \}\\
x~\texttt{===}~y\\
\{ \neg\booleanvalue{\widehat{===}(x, y)} \}\\
\\
\{\true\}\\
x~\texttt{===}~y\\
\{ \isboolean{\widehat{===}(x, y)} \wedge \booleanvalue{\widehat{===}(x, y)} \Leftrightarrow (x = y) \}\\
\\
\end{array}
\]

and it is also similar for $\texttt{!==}$.

The $\mathit{tuple\mbox{-}size}$ and $\mathit{elem}$ functions can be specified directly 
in terms of the built-in declarations used during the translation:

\[
\begin{array}{l}
\{ \istuple{x} \}\\
\mathit{tuple\mbox{-}size}(x)\\
\{ \isinteger{\widehat{\mathit{tuple\mbox{-}size}}(x)} \wedge 
  \integervalue{\widehat{\mathit{tuple\mbox{-}size}}(x)} = \mathit{tuple\mbox{-}size}(x) \}
\end{array}
\]

\[
\begin{array}{l}
\{ \istuple{x} \wedge \isinteger{i} \wedge \integervalue{i} >= 0 \wedge \integervalue{i} < \mathit{tuple\mbox{-}size}(x) \}\\
\mathit{elem}(x, i)\\
\{ \widehat{\mathit{elem}}(x, i) = \mathit{elem}(x, \integervalue{i}) \}
\end{array}
\]

The same can be applied to the $\mathit{hd}$ function

\[
\begin{array}{l}
\{ \isnelist{x} \}\\
\mathit{hd}(x)\\
\{ \widehat{\mathit{hd}}(x) = \mathit{hd}(x) \}
\end{array}
\]

and it is similar for $\mathit{tl}$. Note that, in these last examples, 
the L1 function is not the same as the one mentioned in the postcondition,
which is a built-in L0 function, although we have used the same name.

The functions to mention the term types can also be specified 
directly with the built-in declared L0 functions:

\[
\begin{array}{l}
\{ \true \}\\
\isinteger{x}\\
\{ \isboolean{\widehat{\isinteger{x}}} \wedge 
  \booleanvalue{\widehat{\isinteger{x}}} \Leftrightarrow \isinteger{x} \}
\end{array}
\]

and it is similar for the remaining types.

If some Elixir operator cannot be modelled with function specifications like the
ones shown in this section, they can be defined as L1 expressions with its own 
translation into L0, as we did to model the short-circuit semantics of the 
\verb|and| and \verb|or| operators.

\subsection{Term size modelling}

At some point, it will be required to reason about termination, mainly when 
verifying recursive Elixir function definitions. With that purpose, we have 
considered an uninterpreted function to assign an integer value to $\Term$s

\begin{verbatim}
(declare-fun term_size (Term) Int)
\end{verbatim}

and a set of axioms based on their types

\[
\begin{array}{l}
\termSize{\mathit{nil}} = 1\\
\forall x. \isinteger{x} \Rightarrow \termSize{x} = 1\\
\forall x. \isboolean{x} \Rightarrow \termSize{x} = 1\\
\forall x. \isnelist{x} \Rightarrow \termSize{x} = 1 + \termSize{\mathit{hd}(x)} + \termSize{\mathit{tl}(x)}\\
\forall x. \istuple{x} \Rightarrow \forall i. i >= 0 \wedge i < \mathit{tuple\mbox{-}size}(x) \Rightarrow \termSize{\mathit{elem}(x, i)} < \termSize{x}\\
\end{array}
\]

Note that this is a proposal. We have not worked on this for the moment, as
termination reasoning is not a goal for this project and is intended to be
addressed in future work.

\section{Implementation}
\label{ir:l1implementation}

In this section, we present our implementation for the L1 verification \gls{ir}
in Elixir.

\subsection{Overview}
\label{ir:dslexample}

We have implemented a \gls{dsl} in Elixir to write and verify L1 programs. The
macro \verb|with_local_env/1| provides a default environment with a fresh Z3
connection that is injected as the first argument of its inner \gls{dsl} macros
(i.e. \verb|assert/2|, \verb|havoc/2|, etc.) and is closed once all of them have
been evaluated. As in our \acrshort{smt} binding, \verb|with_local_env/1| is a
convenient wrapper around \verb|with_env/2|, which allows to provide a custom or
reused connection and does not close it automatically.

Here are some examples that succeed to verify according to the Elixir behavior 
explained in Section \ref{prelim:elixir}:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
import Boogiex

with_local_env do
  assert 4 - 2 === 6 - 4
  assert (false or 2) === 2
  assert 3 > 2 and 1 <= 1
  assert elem({1, 2, 3}, 0) === 1
  assert [1 | [2 | [3 | []]]] === [1, 2, 3]
  assert true or true + true

  havoc x
  assert x === x
  assert not (x !== x)

  block do
    assume x === 2
    assert is_integer(x), "This should not fail"
  end

  assert is_integer(x), "This should fail"

  havoc a
  havoc b
  havoc c

  assume is_integer(a) and is_integer(b)
  assume is_integer(a) and is_integer(b) and is_integer(c)

  assume a === b
  assume b === c
  assert a === c

  assert false, "This should fail"
end
\end{lstlisting}

The package also exposes the corresponding translation functions between
\gls{dsl}s for implementing other tools on top of them.

\subsection{Details}
\label{ir:details}

We are going to explain our implementation in a schematic way in order to give
its main idea. 

First, we implement a function to translate Elixir \gls{ast} corresponding to L1
expressions (i.e. its \gls{dsl}), together with an assumption in terms of L0, 
into the term that it represents and L0 code (i.e. also its \gls{dsl}) that
models its semantics:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec translate_l1_exp(L0Exp.ast, L1Exp.ast) 
  :: {L0Exp.ast, L0Exp.ast}
\end{lstlisting}

Its definition syntax matches pretty closely the formal version, as in this case
for nonempty lists:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
def translate_l1_exp(assumption, [{:|, _, [h, t]}]) do
  {head, head_sem} = translate_l1_exp(assumption, h)
  {tail, tail_sem} = translate_l1_exp(assumption, t)
  term = quote(do: :cons.(unquote(head), unquote(tail)))

  {
    term,
    quote do
      unquote(head_sem)
      unquote(tail_sem)
      add :is_nonempty_list.(unquote(term))
      add :hd.(unquote(term)) == unquote(head)
      add :tl.(unquote(term)) == unquote(tail)
    end
  }
end
\end{lstlisting}

This translation relies on a state of tuple constructors that are declared on 
demand, and we also provide a mechanism to indicate the context of the program 
in order to report helpful error messages, but we have omitted such details in 
order to simplify. 

The tuple constructor state has to be managed carefully, because an SMT-LIB
\verb|pop| command can remove definitions from the solver, created after the
previous \verb|push|, and this must be always reflected in our state to be 
synchronized.

Then, we also implement a function to translate Elixir \gls{ast} corresponding
to L1 statements into L0 code:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec translate_l1_stm(L1Stm.ast) :: L0Exp.ast
\end{lstlisting}

It also matches closely the formal version, as in this case for the 
\verb|assert| statement:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
def translate_l1_stm([{:assert, _, [f]}]) do
  {term, term_sem} = translate_l1_exp(nil, f)

  quote do
    when_unsat add !:is_boolean.(unquote(term)) do
    else
      fail
    end

    when_unsat add !:boolean_val.(unquote(term)) do
      add :boolean_val.(unquote(term))
    else
      fail
    end
  end
end
\end{lstlisting}

Finally, this allows us to implement a public \gls{api} for the package which
defines the corresponding macros from the example at Section
\ref{ir:dslexample}. They translate the L1 \gls{dsl} into L0 and evaluate it as
in Section \ref{integ:l0implementation}. A verification function for L1
statements can be implemented in terms of it as follows but, in contrast to the
one presented in Section \ref{integ:l0implementation}, our current
implementation returns verification error reports instead of raising an
exception and stopping the whole process:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec verify_l1(Env.t(), L1Stm.ast()) :: [term()]
def verify_l1(env, s) do
  L0Exp.eval(
    env,
    translate_l1_stm(s)
  )
end
\end{lstlisting}

Also, we have introduced some strategies to improve its performance. For
example, instead of translating the whole L1 code into L0 and then evaluate it,
we can translate and evaluate a sequence of L1 statements one at a time.
