{"rule":"TO_DO_HYPHEN","sentence":"^\\QREADME.md LaTeX code formatter Search for TODOs\\E$"}
{"rule":"POSSESSIVE_APOSTROPHE","sentence":"^\\QThe \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q built-in functions for lists allow to respectively extract the first and second components of a cons cell:\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is a number, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is a variable, and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is a function symbol of arity \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"POSSESSIVE_APOSTROPHE","sentence":"^\\QThe \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q built-in functions for lists allow to respectively obtain the first and second components of a cons cell:\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QIt is intended to be implemented as Elixir expressions that send SMT-LIB statements to an smt solver and will allow us to define a verification \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q on top of it.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QIn order to implement our system, we will require to be able to interact with an smt solver from Elixir.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere other involved types like \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q are defined similarly.\\E$"}
{"rule":"PRE_AND_POST_NN","sentence":"^\\QHere the word overloaded means that there could be many pre/post-condition pairs for each function.\\E$"}
{"rule":"POSSESSIVE_APOSTROPHE","sentence":"^\\QThe \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q built-in functions for lists allow us to respectively obtain the first and second components of a cons cell:\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QIn this chapter, we develop an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for verification that is intended to be particularly suitable for languages like Elixir.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QWhen it comes to assign a meaning to L1 statements and expressions, as this is an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, we translate them into L0 expressions to verify them.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is the type of the literal, which can be determined at compile time since it is a literal, and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is the constant in the underlying logic represented by that literal.\\E$"}
{"rule":"PRE_AND_POST_NN","sentence":"^\\QThen, for each pre/post-condition pair of the specification of the function being applied, we generate code that checks whether the precondition holds and, in case it does, we assert both the precondition and postcondition.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qand it will be extended if we model other numeric types such as \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qand it in the same ways for \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qand it is also similar for \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qand it is similar for \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qand it is similar for the remaining types.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere other involved types like \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q are defined similarly, many of them as an alias to built-in Elixir value types.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QIn practice, this task will be delegated to an smt solver as if it were a black box that can solve the problem.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QThe \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q expression corresponds to an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q in SMT-LIB:\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QAssuming the defined macros to be in scope, and a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q variable that represents a fresh connection with an smt solver and has the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sort already defined, this would be a simple example of its usage:\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q represents a function invocation when the first component is the function name, and the third one its arguments.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QElixir also offers several advanced constructs to deal with macros, such as \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to interpolate an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q list as the arguments of a function invocation, and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to escape \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q data (e.g. it allows to introduce some given \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q as data instead of as code in a macro definition):\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QWe are interested in these features due to the integration of an smt solver in Elixir, which will surely be an external process.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QIt defines a solver-agnostic standard language with a Lisp-like syntax to configure a solver, manage it, encode an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q problem instance and query for solutions.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere some commands have a specific success response, like \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q | \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q | \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QAlso, WebAssembly is an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q intended to be executable at native speed in web browsers [reference].\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QAlso, WebAssembly is an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q intended to be executable at native speed in web browsers.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QWhy3, a platform for deductive program verification, provides a language for specification and programming, WhyML, that can be used as an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for the verification of C, Java, Ada, or to obtain an automated correct-by-construction OCaml program \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QAlso, Why3 is a platform for deductive program verification that provides a language for specification and programming, WhyML, that can be used as an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for the verification of C, Java, Ada, or to obtain an automated correct-by-construction OCaml program \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qsmt solvers in particular are gaining popularity for this task, and some current options are Z3 from Microsoft, Z3, CVC4, MathSAT and Yices.\\E$"}
