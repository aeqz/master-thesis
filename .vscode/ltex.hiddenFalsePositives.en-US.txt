{"rule":"TO_DO_HYPHEN","sentence":"^\\QREADME.md LaTeX code formatter Search for TODOs\\E$"}
{"rule":"POSSESSIVE_APOSTROPHE","sentence":"^\\QThe \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q built-in functions for lists allow to respectively extract the first and second components of a cons cell:\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is a number, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is a variable, and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is a function symbol of arity \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"POSSESSIVE_APOSTROPHE","sentence":"^\\QThe \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q built-in functions for lists allow to respectively obtain the first and second components of a cons cell:\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QIt is intended to be implemented as Elixir expressions that send SMT-LIB statements to an smt solver and will allow us to define a verification \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q on top of it.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QIn order to implement our system, we will require to be able to interact with an smt solver from Elixir.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere other involved types like \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q are defined similarly.\\E$"}
{"rule":"PRE_AND_POST_NN","sentence":"^\\QHere the word overloaded means that there could be many pre/post-condition pairs for each function.\\E$"}
{"rule":"POSSESSIVE_APOSTROPHE","sentence":"^\\QThe \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q built-in functions for lists allow us to respectively obtain the first and second components of a cons cell:\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QIn this chapter, we develop an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for verification that is intended to be particularly suitable for languages like Elixir.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QWhen it comes to assign a meaning to L1 statements and expressions, as this is an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, we translate them into L0 expressions to verify them.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is the type of the literal, which can be determined at compile time since it is a literal, and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is the constant in the underlying logic represented by that literal.\\E$"}
{"rule":"PRE_AND_POST_NN","sentence":"^\\QThen, for each pre/post-condition pair of the specification of the function being applied, we generate code that checks whether the precondition holds and, in case it does, we assert both the precondition and postcondition.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qand it will be extended if we model other numeric types such as \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qand it in the same ways for \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qand it is also similar for \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qand it is similar for \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qand it is similar for the remaining types.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere other involved types like \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q are defined similarly, many of them as an alias to built-in Elixir value types.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QIn practice, this task will be delegated to an smt solver as if it were a black box that can solve the problem.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QThe \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q expression corresponds to an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q in SMT-LIB:\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QAssuming the defined macros to be in scope, and a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q variable that represents a fresh connection with an smt solver and has the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sort already defined, this would be a simple example of its usage:\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q represents a function invocation when the first component is the function name, and the third one its arguments.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QElixir also offers several advanced constructs to deal with macros, such as \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to interpolate an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q list as the arguments of a function invocation, and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to escape \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q data (e.g. it allows to introduce some given \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q as data instead of as code in a macro definition):\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QWe are interested in these features due to the integration of an smt solver in Elixir, which will surely be an external process.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QIt defines a solver-agnostic standard language with a Lisp-like syntax to configure a solver, manage it, encode an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q problem instance and query for solutions.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere some commands have a specific success response, like \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q | \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q | \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QAlso, WebAssembly is an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q intended to be executable at native speed in web browsers [reference].\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QAlso, WebAssembly is an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q intended to be executable at native speed in web browsers.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QWhy3, a platform for deductive program verification, provides a language for specification and programming, WhyML, that can be used as an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for the verification of C, Java, Ada, or to obtain an automated correct-by-construction OCaml program \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QAlso, Why3 is a platform for deductive program verification that provides a language for specification and programming, WhyML, that can be used as an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for the verification of C, Java, Ada, or to obtain an automated correct-by-construction OCaml program \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qsmt solvers in particular are gaining popularity for this task, and some current options are Z3 from Microsoft, Z3, CVC4, MathSAT and Yices.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere, for example, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is a combinator that denotes the end of the stream of data being parsed, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q parses the success response of SMT-LIB commands that do not have a specific one, and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q parses specific responses such as the one for \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QL0 is intended to be implemented as Elixir expressions that send SMT-LIB statements to an smt solver.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is a sort that must be previously defined in the smt solver.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QIn practice, this task will be delegated to an smt solver as if it were a black box that can determine whether a set of first-order formulas is unsatisfiable.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QAssuming the defined macros to be in scope, and a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q variable that represents a fresh connection with an smt solver which has the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sort already defined, this would be a simple example of the usage of the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q macro:\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QElixir also offers several advanced constructs to deal with macros, such as \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to interpolate an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q list as the arguments of a function invocation:\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qand it is in the same way for \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QA more complex usage example is shown in Appendix \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, which it corresponds to a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q problem instead of an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q one.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QA more complex usage example is shown in Appendix \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, which corresponds to a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q problem instead of an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q one.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qmeaning that there exists an assignment for the defined variables that satisfies the specified formulas, thus the graph has a Hamiltonian path.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QThis appendix shows a longer usage example of our developed \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to communicate with an smt solver from Elixir.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QL0 is intended to be implemented as Elixir expressions that send SMT-LIB commands to an smt solver.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q denote a specified precondition and a postcondition, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q are the argument patterns and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is its defined body.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q denote a specified precondition and a postcondition, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q are the parameter patterns and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is its defined body.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QIn order to provide an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for programmers to use this verification system in their own Elixir \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qs, we define a module that can be imported by means of the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q built-in macro.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QIn order to provide an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for programmers to use this verification system in their own Elixir \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qs, we have defined a module that can be imported by means of the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q built-in macro.\\E$"}
{"rule":"IT_VBZ","sentence":"^\\QIt also explain some of its implementation details briefly.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhich verifies during compilation and leaves in there the function definitions without verification code to be executed.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is the logic variable corresponding to the L1 variable \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QElixir protocols are mechanisms to achieve polymorphism and, in order to implement a connection with an smt solver, it suffices to define an Elixir module with a data type that implements these two functions.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QElixir protocols are mechanisms to achieve polymorphism and, in order to implement a connection with an smt solver, it suffices to define an Elixir module with a data type that implements the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q protocol with these two functions.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QThen, we must define a translation from this \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q into the smt solver \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for its verification and, finally, we must also provide a mechanism to translate a subset of the Elixir programming language into the verification \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, together with an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for allowing its usage when writing Elixir code.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QThen, we must define a translation from this \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q into the smt solver \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for its verification and, finally, we must also provide a mechanism to translate a subset of the Elixir programming language into the verification \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, together with an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for allowing its usage when writing Elixir code:\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QThen, we must define a translation from this \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q into the smt solver \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for its verification and, finally, we must also provide a mechanism to translate a subset of the Elixir programming language into the verification \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, together with an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for allowing its usage when writing Elixir code like in the following draft:\\E$"}
{"rule":"PRE_AND_POST_NN","sentence":"^\\QThen, we check that at least one preconditions holds and, finally, for each pre/post-condition pair of the specification of the function being applied, we generate code that checks whether the precondition holds and, in case it does, we assert both the precondition and postcondition.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qand it could be extended if we modelled other numeric types such as \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
